package cmd

import (
	"errors"
	"fmt"
	"net"
	"path/filepath"
	"strings"
	"time"

	"github.com/onerobotics/fexcel/excel"
	"github.com/onerobotics/fexcel/fanuc"
	"github.com/onerobotics/fexcel/fexcel"
	"github.com/spf13/cobra"
)

var (
	// used for flags
	timeout int
)

var commentCmd = &cobra.Command{
	Use:   "comment ./path/to/spreadsheet.xlsx ipAddress [more ipAddresses]",
	Short: "Set FANUC robot comments",
	Long:  "Set FANUC robots comments based on the provided Excel spreadsheet",
	Args:  validateArgs,
	RunE:  main,
}

func init() {
	rootCmd.AddCommand(commentCmd)
	commentCmd.Flags().IntVarP(&timeout, "timout", "", 500, "timeout value in milliseconds")
}

func validateArgs(cmd *cobra.Command, args []string) error {
	if len(args) < 2 {
		return errors.New("requires a spreadsheet and at least one host")
	}
	fpath := args[0]
	ext := filepath.Ext(fpath)
	if ext != ".xlsx" {
		return errors.New("requires a .xlsx file generated by Excel 2007 or later")
	}

	hosts := args[1:]
	for _, host := range hosts {
		if net.ParseIP(host) == nil {
			return fmt.Errorf("%s is not a valid IP address", host)
		}
	}

	return nil
}

func main(cmd *cobra.Command, args []string) error {
	fmt.Printf(fexcel.Logo())

	fpath := args[0]
	hosts := args[1:]

	f, err := excel.NewFile(fpath, globalFlags.Offset)
	if err != nil {
		return err
	}

	err = setLocations(f)
	if err != nil {
		return err
	}

	c := fanuc.NewMultiUpdater(hosts, &fanuc.CommentToolUpdater{time.Duration(timeout) * time.Millisecond})

	dataTypes := []fanuc.DataType{
		fanuc.Numreg,
		fanuc.Posreg,
		fanuc.Ualm,
		fanuc.Rin,
		fanuc.Rout,
		fanuc.Din,
		fanuc.Dout,
		fanuc.Gin,
		fanuc.Gout,
		fanuc.Ain,
		fanuc.Aout,
		fanuc.Sreg,
		fanuc.Flag,
	}

	var definitions []fanuc.Definition
	for _, d := range dataTypes {
		if f.Locations[d].Axis == "" || f.Locations[d].Sheet == "" {
			continue
		}

		defs, err := f.Definitions(d)
		if err != nil {
			return err
		}

		fmt.Printf("Found %d %ss.\n", len(defs), d.VerboseName())

		definitions = append(definitions, defs...)
	}

	fmt.Printf("\nUpdating %d comments on %d %s... ", len(definitions), len(hosts), pluralize("host", len(hosts)))

	startTime := time.Now()

	err = c.Update(definitions)
	if err != nil {
		return err
	}

	fmt.Printf("finished in %s.\n\n", time.Since(startTime))

	for _, warning := range c.Warnings {
		fmt.Printf("[warning] %s\n", warning)
	}

	for host, errs := range c.Errors {
		for _, err := range errs {
			fmt.Printf("[error] %s: %s\n", host, err)
		}
	}

	if len(c.Errors) > 0 {
		return fmt.Errorf("Finished with %d errors", len(c.Errors))
	}

	return nil
}

func parseLocation(spec string) (sheet string, axis string, err error) {
	if spec == "" {
		return
	}

	parts := strings.Split(spec, ":")

	switch len(parts) {
	case 2:
		sheet, axis = parts[0], parts[1]
		return
	case 1:
		// e.g. A2
		sheet = globalFlags.Sheet
		axis = spec
		return
	}

	err = fmt.Errorf("Invalid start cell specification: %q", spec)
	return
}

func pluralize(word string, i int) string {
	if i == 1 {
		return word
	} else {
		return word + "s"
	}
}

func setLocations(f *excel.File) error {
	locationSpecs := []struct {
		dataType fanuc.DataType
		s        string
	}{
		{fanuc.Numreg, globalFlags.Numregs},
		{fanuc.Posreg, globalFlags.Posregs},
		{fanuc.Ualm, globalFlags.Ualms},
		{fanuc.Rin, globalFlags.Rins},
		{fanuc.Rout, globalFlags.Routs},
		{fanuc.Din, globalFlags.Dins},
		{fanuc.Dout, globalFlags.Douts},
		{fanuc.Gin, globalFlags.Gins},
		{fanuc.Gout, globalFlags.Gouts},
		{fanuc.Ain, globalFlags.Ains},
		{fanuc.Aout, globalFlags.Aouts},
		{fanuc.Sreg, globalFlags.Sregs},
		{fanuc.Flag, globalFlags.Flags},
	}

	for _, spec := range locationSpecs {
		sheet, axis, err := parseLocation(spec.s)
		if err != nil {
			return err
		}

		f.SetLocation(spec.dataType, axis, sheet)
	}

	return nil
}
