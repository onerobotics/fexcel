package cmd

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/onerobotics/fexcel/fexcel"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

const configFile = ".fexcel.yaml"

var (
	cfgFile   string
	save      bool
	globalCfg fexcel.Config
)

var rootCmd = &cobra.Command{
	Use:   "fexcel",
	Short: "Process a spreadsheet and report what fexcel sees",
	Args:  validateRootArgs,
	/*
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return nil
		},
	*/
	RunE: rootMain,
	PersistentPostRunE: func(cmd *cobra.Command, args []string) error {
		if save {
			fmt.Printf("saving flagset to config file... ")
			if _, err := os.Stat(configFile); os.IsNotExist(err) {
				_, err := os.Create(configFile)
				if err != nil {
					return err
				}
			}
			err := viper.WriteConfig()
			if err != nil {
				return err
			}
			fmt.Println("done!")
		}

		if !globalCfg.NoUpdate {
			err := fexcel.CheckForUpdates(os.Stdout)
			if err != nil {
				return errors.New("failed to get latest version id from GitHub.")
			}
		}

		return nil
	},
}

func init() {
	cobra.OnInitialize(initConfig)

	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is ./"+configFile+")")
	rootCmd.PersistentFlags().BoolVarP(&save, "save", "", false, "save flagset to config file")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Numregs, "numregs", "", "start cell of numeric register ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Posregs, "posregs", "", "start cell of position register ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Ualms, "ualms", "", "start cell of user alarm ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Gins, "gins", "", "start cell of group input ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Gouts, "gouts", "", "start cell of group output ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Rins, "rins", "", "start cell of robot input ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Routs, "routs", "", "start cell of robot output ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Dins, "dins", "", "start cell of digital input ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Douts, "douts", "", "start cell of digital output ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Ains, "ains", "", "start cell of analog input ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Aouts, "aouts", "", "start cell of analog output ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Sregs, "sregs", "", "start cell of string register ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Flags, "flags", "", "start cell of flag ids")
	rootCmd.PersistentFlags().StringVar(&globalCfg.Sheet, "sheet", "Sheet1", "default sheet to look at when unspecified in the start cell")
	rootCmd.PersistentFlags().IntVar(&globalCfg.Offset, "offset", 1, "column offset between ids and comments")
	rootCmd.PersistentFlags().BoolVar(&globalCfg.NoUpdate, "noupdate", false, "don't check for fexcel updates")

	viper.BindPFlag("numregs", rootCmd.PersistentFlags().Lookup("numregs"))
	viper.BindPFlag("posregs", rootCmd.PersistentFlags().Lookup("posregs"))
	viper.BindPFlag("ualms", rootCmd.PersistentFlags().Lookup("ualms"))
	viper.BindPFlag("gins", rootCmd.PersistentFlags().Lookup("gins"))
	viper.BindPFlag("gouts", rootCmd.PersistentFlags().Lookup("gouts"))
	viper.BindPFlag("rins", rootCmd.PersistentFlags().Lookup("rins"))
	viper.BindPFlag("routs", rootCmd.PersistentFlags().Lookup("routs"))
	viper.BindPFlag("dins", rootCmd.PersistentFlags().Lookup("dins"))
	viper.BindPFlag("douts", rootCmd.PersistentFlags().Lookup("douts"))
	viper.BindPFlag("ains", rootCmd.PersistentFlags().Lookup("ains"))
	viper.BindPFlag("aouts", rootCmd.PersistentFlags().Lookup("aouts"))
	viper.BindPFlag("sregs", rootCmd.PersistentFlags().Lookup("sregs"))
	viper.BindPFlag("flags", rootCmd.PersistentFlags().Lookup("flags"))
	viper.BindPFlag("sheet", rootCmd.PersistentFlags().Lookup("sheet"))
	viper.BindPFlag("Offset", rootCmd.PersistentFlags().Lookup("offset"))
}

func initConfig() {
	ext := filepath.Ext(configFile)
	name := strings.TrimSuffix(configFile, ext)
	viper.SetConfigName(name)
	viper.SetConfigType(ext[1:]) // remove .
	viper.AddConfigPath(".")

	if err := viper.ReadInConfig(); err == nil {
		fmt.Println("Using config file:", viper.ConfigFileUsed())
		viper.Unmarshal(&globalCfg)
	} else {
		if _, ok := err.(viper.ConfigFileNotFoundError); ok {
			// config file not found, but that's ok
		} else {
			// config file found, but another error was produced.
			fmt.Println("Error reading config file: ", err)
		}
	}
}

func validateRootArgs(cmd *cobra.Command, args []string) error {
	if len(args) != 1 {
		return errors.New("requires a spreadsheet")
	}

	ext := filepath.Ext(args[0])
	if ext != ".xlsx" {
		return errors.New("requires a .xlsx file generated by Excel 2007 or later")
	}

	return nil
}

func rootMain(cmd *cobra.Command, args []string) error {
	fmt.Printf(fexcel.Logo())

	fpath := args[0]

	f, err := fexcel.NewFile(fpath, globalCfg)
	if err != nil {
		return err
	}
	err = f.Open()
	if err != nil {
		return err
	}

	if len(f.Locations) == 0 {
		fmt.Println("No location flags specified.")
		return nil
	}

	for d, _ := range f.Locations {
		defs, err := f.Definitions(d)
		if err != nil {
			return err
		}

		fmt.Printf("Found %d %ss.\n", len(defs), d.VerboseName())
	}

	return nil
}

func Execute() {
	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}
