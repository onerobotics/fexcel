package cmd

import (
	"errors"
	"fmt"
	"net"
	"path/filepath"
	"time"

	"github.com/onerobotics/fexcel/fexcel"
	"github.com/spf13/cobra"
)

var setCmd = &cobra.Command{
	Use:   "set ./path/to/spreadsheet.xlsx ipAddress [more ipAddresses]",
	Short: "Set FANUC robots comments based on the provided Excel spreadsheet",
	Args:  validateSetArgs,
	RunE:  setMain,
}

func init() {
	rootCmd.AddCommand(setCmd)
}

func validateSetArgs(cmd *cobra.Command, args []string) error {
	if len(args) < 2 {
		return errors.New("requires a spreadsheet and at least one host IP address")
	}

	ext := filepath.Ext(args[0])
	if ext != ".xlsx" {
		return errors.New("requires a .xlsx file generated by Excel 2007 or later")
	}

	for _, host := range args[1:] {
		if net.ParseIP(host) == nil {
			return fmt.Errorf("%s is not a valid IP address", host)
		}
	}

	return nil
}

func setMain(cmd *cobra.Command, args []string) error {
	fmt.Printf(fexcel.Logo())

	fpath, hosts := args[0], args[1:]

	diffCmd, err := fexcel.NewDiffCommand(fpath, globalCfg, hosts...)
	if err != nil {
		return err
	}

	definitions := make(map[string][]fexcel.Definition) // key is host
	for dataType, _ := range diffCmd.Locations() {
		comparisons, err := diffCmd.Compare(dataType)
		if err != nil {
			return err
		}

		fmt.Printf("Found %d %s\n", len(comparisons), fexcel.Pluralize(dataType.VerboseName(), len(comparisons)))
		for _, c := range comparisons {
			for host, got := range c.Got {
				if got != c.Want {
					// see if it's because want is too long
					if maxLength := fexcel.MaxLengthFor(dataType); len(c.Want) > maxLength {
						if got == c.Want[:maxLength] {
							continue
						}
					}
					definitions[host] = append(definitions[host], fexcel.Definition{Type: dataType, Id: c.Id, Comment: c.Want})
				}
			}
		}
		for _, host := range hosts {
			fmt.Printf("  %d %s on %s\n", len(definitions[host]), fexcel.Pluralize("difference", len(definitions[host])), host)
		}
	}

	fmt.Println("")

	if len(definitions) == 0 {
		fmt.Println("Comments are up to date.")
		return nil
	}

	for _, warning := range diffCmd.Warnings() {
		fmt.Printf("[warning] %s\n", warning)
	}

	for host, defs := range definitions {
		fmt.Printf("\nSetting %d %s on %s\n", len(defs), fexcel.Pluralize("comment", len(defs)), host)
	}

	startTime := time.Now()
	c := fexcel.NewMultiSetter(hosts, &fexcel.CommentToolSetter{time.Duration(globalCfg.Timeout) * time.Millisecond})
	err = c.Set(definitions)
	if err != nil {
		return err
	}
	fmt.Printf("\nFinished in %s.\n\n", time.Since(startTime))

	if len(c.Errors) > 0 {
		errorCount := 0
		for host, errs := range c.Errors {
			for _, err := range errs {
				fmt.Printf("[error] %s: %s\n", host, err)
				errorCount++
			}
		}
		fmt.Println("")

		return fmt.Errorf("Finished with %d %s on %d %s", errorCount, fexcel.Pluralize("error", errorCount), len(c.Errors), fexcel.Pluralize("host", len(c.Errors)))
	}

	return nil
}
